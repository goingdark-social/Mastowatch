# Production Docker Compose Configuration for MastoWatch
# 
# For environment variable documentation, see: docs/ENVIRONMENT.md
# 
# This file contains production defaults. Use docker-compose.override.yml
# for development-specific configurations.

# Shared environment variables for backend services
x-backend-env: &backend-env
  # Required Configuration - Set these in your deployment environment
  INSTANCE_BASE: "${INSTANCE_BASE}"
  ADMIN_TOKEN: "${ADMIN_TOKEN}"
  BOT_TOKEN: "${BOT_TOKEN}"
  DATABASE_URL: "${DATABASE_URL}"
  REDIS_URL: "${REDIS_URL}"
  API_KEY: "${API_KEY}"
  WEBHOOK_SECRET: "${WEBHOOK_SECRET}"
  
  # Safety Controls
  DRY_RUN: "${DRY_RUN:-false}"  # Production default: disabled
  PANIC_STOP: "${PANIC_STOP:-false}"
  SKIP_STARTUP_VALIDATION: "${SKIP_STARTUP_VALIDATION:-false}"
  
  # Frontend Integration
  CORS_ORIGINS: '${CORS_ORIGINS:-["https://your-domain.com"]}'
  UI_ORIGIN: "${UI_ORIGIN}"
  
  # Optional OAuth Configuration
  OAUTH_CLIENT_ID: "${OAUTH_CLIENT_ID:-}"
  OAUTH_CLIENT_SECRET: "${OAUTH_CLIENT_SECRET:-}"
  OAUTH_REDIRECT_URI: "${OAUTH_REDIRECT_URI:-}"
  
  # Performance Tuning
  POLL_ADMIN_ACCOUNTS_INTERVAL: "${POLL_ADMIN_ACCOUNTS_INTERVAL:-30}"
  POLL_ADMIN_ACCOUNTS_LOCAL_INTERVAL: "${POLL_ADMIN_ACCOUNTS_LOCAL_INTERVAL:-30}"
  QUEUE_STATS_INTERVAL: "${QUEUE_STATS_INTERVAL:-60}"
  BATCH_SIZE: "${BATCH_SIZE:-100}"
  MAX_PAGES_PER_POLL: "${MAX_PAGES_PER_POLL:-10}"

services:
  api:
    build:
      context: ./backend
      dockerfile: Dockerfile
    ports:
      - "8080:8080"
    environment:
      <<: *backend-env
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_started
      migrate:
        condition: service_completed_successfully
    healthcheck:
      test: ["CMD-SHELL", "python -c \"import urllib.request,sys; sys.exit(0 if urllib.request.urlopen('http://localhost:8080/healthz').getcode()==200 else 1)\""]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    ports:
      - "3000:80"
    depends_on:
      - api
    healthcheck:
      test: ["CMD-SHELL","wget -qO- http://localhost/ >/dev/null 2>&1 || exit 1"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 10s

  worker:
    build:
      context: ./backend
      dockerfile: Dockerfile
    command: ["celery", "-A", "app.tasks.celery_app", "worker", "--loglevel=INFO", "--concurrency=2"]
    environment:
      <<: *backend-env
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_started
      migrate:
        condition: service_completed_successfully
    healthcheck:
      # Verify Redis is reachable (simple k8s-compatible exec probe)
      test: ["CMD-SHELL","python -c \"import os,sys; import redis; r=redis.from_url(os.getenv('REDIS_URL')); sys.exit(0 if r.ping() else 1)\""]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  beat:
    build:
      context: ./backend
      dockerfile: Dockerfile
    command: ["celery", "-A", "app.tasks.celery_app", "beat", "--loglevel=INFO"]
    environment:
      <<: *backend-env
      # Ensure celery_sqlalchemy_scheduler uses Postgres instead of defaulting to a local SQLite file
      SQLALCHEMY_DATABASE_URI: "${DATABASE_URL}"
      # Also set the beat-specific URL that the scheduler might look for
      CELERY_BEAT_SQLALCHEMY_URL: "${DATABASE_URL}"
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_started
      migrate:
        condition: service_completed_successfully
    healthcheck:
      test: ["CMD-SHELL","python -c \"import os,sys; import redis; r=redis.from_url(os.getenv('REDIS_URL')); sys.exit(0 if r.ping() else 1)\""]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  migrate:
    build:
      context: ./backend
      dockerfile: Dockerfile
    command: ["alembic", "upgrade", "heads"]
    environment:
      <<: *backend-env
    depends_on:
      db:
        condition: service_healthy

  db:
    image: postgres:18
    environment:
      POSTGRES_DB: "${POSTGRES_DB:-mastowatch}"
      POSTGRES_USER: "${POSTGRES_USER:-mastowatch}"
      POSTGRES_PASSWORD: "${POSTGRES_PASSWORD}"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-mastowatch} -d ${POSTGRES_DB:-mastowatch}"]
      interval: 5s
      timeout: 5s
      retries: 10

  redis:
    image: redis:8
    command: ["redis-server", "--appendonly", "yes"]
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:
